# React 创建更新

创建更新的方式：

* ReactDOM.render || hydrate

* setState

* forceUpdate

## render

1. 创建 reactRoot

2. 创建 FiberRoot 和 HostRootFiber

3. 创建更新

render 和 hydrate 调用 legacyRenderSubtreeIntoContainer，唯一不同就是 forceHydrate 的参数不同，render 和 hydrate 本质的不同就是是否对原来 #root 节点内的 DOM 节点进行复用

legacyRenderSubtreeIntoContainer 根据 #root 中是否有 _reactRootContainer 判断是否为第一次渲染（mount）

mount 阶段调用 legacyCreateRootFromDOMContainer 创建 reactRoot 并挂载到 #root._reactRootContainer 上，legacyCreateRootFromDOMContainer 根据 shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container) 判断是否对 #root 中的子节点进行复用，如果不复用就 remove 所有的子节点，其中 shouldHydrateDueToLegacyHeuristic 判断是否有子节点且子节点上是否有 data-reactroot 的属性，如果有则 shouldHydrate 为 true，进行子节点复用，之后创建的 fiberRoot 也跟是否 hydrate 有关

mount 阶段创建 reactRoot 同时创建了 FiberRoot 和 HostRootFiber，之后对 render 的 callbak 的 this 指向进行 处理，但 mount 时指向 null，然后调用 callback。之后非批处理进行更新 unbatchedUpdates，unbatchedUpdates 传入回调函数 () => updateContainer(children, fiberRoot, parentComponent, callback) ，在 unbatchedUpdates 内部进行更新 updateContainer

updateContainer 中获取 HostRootFiber，获取相应信息后 computeExpirationForFiber(currentTime, current, suspenseConfig) 算出 expirationTime，再 createUpdate(expirationTime, suspenseConfig) 创建 update，createUpdate 将一些信息添加到 update 对象上并返回，之后 enqueueUpdate(current, update) 处理后调用 scheduleWork(current, expirationTime) 进入调度更新
