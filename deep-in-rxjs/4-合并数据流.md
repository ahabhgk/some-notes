# 合并数据流

## 合并类操作符

### concat 首尾相连

concat 先从第一个 Observable 对象获取数据，第一个 Observable 就是调用 concat 的那个对象（类似 `[1, 2].concat([3, 4])`），第一个 complete 之后 concat 会订阅第二个 Observable 以此类推，直至最后一个 Observable complete，concat 的 Observable 才完结

因此前一个 Observable 不 complete，后一个 Observable 就不会开始

```ts
const oba1$ = of(1, 2, 3)
const oba2$ = of(4, 5, 6)
of().pipe(concat(oba1$, oba2$)).subscribe(console.log)
```

### merge 先到先得快速通过

merge 会同时订阅所有的上游对象，一般用于异步数据流

```ts
const source1$ = timer(0, 1000).pipe(map((n) => `A${n}`))
const source2$ = timer(500, 1000).pipe(map((n) => `B${n}`))
merge(source1$, source2$).subscribe(console.log)
// A0
// B0
// A1
// B1
// ...
```

merge 同时订阅是相对于异步来说，实际上仍然是依次订阅，由于订阅 `of(1, 2, 3)` 后还没有来得及订阅后一个，就已经吐出数据，所以输出与 concat 一样

```ts
merge(of(1, 2, 3), of(4, 5, 6)).subscribe(console.log) // 1 2 3 4 5 6
```

有一个 concurrent: number 可选参数用来限流

```ts
const source1$ = time(0, 1000)
const source2$ = time(500, 1000)
const source3$ = time(1000, 1000)
merge(source1$, source2$, source3$, 2).subscribe(console.log)
```

这样 source3$ 就不会进行订阅，除非 source1$ 或 source2$ complete

例子：因为在移动设备上 touchend 事件出现得比 click 更早，这两个事件的处理是一模一样的但是 fromEvent 不能同时获得两个事件的数据流，这时候就要借助 merge 的力量

```ts
const click$ = fromEvent(element, 'click')
const touchend$ = fromEvent(element, 'touchend')
merge(click$, touchend$).subscribe(eventHandler)
```

### zip 拉链式组合

就像拉链一样组合

```ts
const age$ = of<number>(27, 25, 29)
const name$ = of<string>('Foo', 'Bar', 'Beer')
const isDev$ = of<boolean>(true, true, false)

zip(age$, name$, isDev$).subscribe(console.log)
// [27, 'Foo', true]
// [25, 'Bar', true]
// [29, 'Beer', false]
```

对于步调不一致时或数量不一致时，会把提前的自动延后，多的删减成少的

```ts
const source1$ = interval(3000)
const source2$ = timer(3000, 1000)
zip(source1$, source2$).subscribe(console.log)
```

![zip](./images/zip.png)

数据积压问题：如果一个吐出速度过慢，zip 会保存吐出速度过快的数据，等待另一个吐出数据，这时如果保存数据量过大，就会占用大量内存，zip 自身解决不了，会有其他方式解决

### combineLatest 合并最后一个数据

> Whenever any input Observable emits a value, it computes a formula using the latest values from all the inputs, then emits the output of that formula.

![combineLatest](./images/combineLatest.png)

```ts
import { combineLatest, timer } from 'rxjs';

const firstTimer = timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
const secondTimer = timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
const combinedTimers = combineLatest(firstTimer, secondTimer);
combinedTimers.subscribe(value => console.log(value));
// Logs
// [0, 0] after 0.5s
// [1, 0] after 1s
// [1, 1] after 1.5s
// [2, 1] after 2s
```

对于同步的，类似于 merge

```ts
const source1$ = of('a', 'b', 'c')
const source2$ = of(1, 2, 3)
const source3$ = of('x', 'y')
source1$.combineLatest(source2$, source3$)
  .subscribe(console.log, null, () => console.log('complete')
// ['c', 3, 'x']
// ['c', 3, 'y']
// 'complete'
```

最后一个参数可以是一个 resultSelector 函数，相当于 `.pipe(map(/* codes */))`

对于多重依赖的 source，就像 cpp 中的多重继承一样，会出现一些反常识的问题

```ts
const original$ = timer(0, 1000)
const source1$ = original$.map(x => `${x}a`)
const source2$ = original$.map(x => `${x}b`)
combineLatest(source1$, source2$).subscribe(
  console.log,
  null,
  () => console.log('complete')
)
// ['0a', '0b']
// ['1a', '0b']
// ['1a', '1b']
// ['2a', '1b']
// ['2a', '2b']

// 对于完全正统的 FRP 的定义，应该是这样
// ['0a', '0b']
// ['1a', '1b']
// ['2a', '2b']
```

![combineLatest-glitch](./images/combineLatest-glitch.png)

如果想要纯正的输出，可以使用 withLatestFrom

### withLatestFrom

